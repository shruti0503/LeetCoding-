class DisjointSet{
    public:
    vector<int>parent;
    vector<int>size;
    DisjointSet(int n){
        parent.resize(n+1);
        size.resize(n+1);
        for(int i=0;i<n;i++){
            parent[i]=i;
        }
    }

    int findParent(int node){
        if(parent[node]==node) return node;
        return parent[node]=findParent(parent[node]);
    }

    void Union(int node1, int node2){
        int parentNode1=findParent(node1);
        int parentNode2=findParent(node2);
        if(parentNode1==parentNode2) return;
        else if(parentNode1>parentNode2){
            size[parentNode1]+=size[parentNode2];
            parent[node2]=parentNode1;
        }
        else{
            size[parentNode2]+=size[parentNode1];
            parent[node1]=parentNode2;
        }

    }
};

class Solution {
public:
// 1.create adjList
//2. dfs traversal -> assign compoentId to the nodes, 
// -> find the component and calculate their respective size
// 3. count malware counts in each component
// 4. evaluate the effect removing each malware node 


// void dfs(int node, vector<bool>& visited, vector<vector<int>>& adjList, 
//          unordered_map<int, int>& componentSize, vector<int>& component, int componentId) {
//     visited[node] = true;  // mark as visited
//     component[node] = componentId;  // assign id to that node
//     componentSize[componentId]++;  // increase the size of that particular component
//     for (int neighbor : adjList[node]) {
//         if (!visited[neighbor]) {
//             dfs(neighbor, visited, adjList, componentSize, component, componentId);
//         }
//     }
// }

int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
    int n = graph.size();
    vector<vector<int>> adjList(n);

    // Build adjacency list from the graph
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (graph[i][j] == 1 && i != j) {
                adjList[i].push_back(j);
            }
        }
    }

    DisjointSet ds(n);
    // component made
    for(int i=0;i<n;i++){
        for(int j:adjList[i]){
             ds.Union(i, j);

        }
       
    }

    // count malware
    unordered_map<int, pair<int,int>>Nodes;
   //{componentId -> {malwareCount, componentSize}}
   for(int i=0;i<n;i++){
     int  parent=ds.findParent(i);
     Nodes[parent].second++;    // component size
   }
   for(int node:initial){
    int parent=ds.findParent(node);
    Nodes[parent].first++; // malware count
   }

   int maxSaved=0, result=-1;
   for(int node: initial){
    int root=ds.findParent(node);
    if(Nodes[root].first==1){
        int saved=Nodes[root].second;
        if(saved>maxSaved || (saved==maxSaved and node<result)){
            maxSaved=saved;
            result=node;
        }
    }
   }

   if (result == -1) {
        result = *min_element(initial.begin(), initial.end());
    }

    return result;





    //DFS APPROACH 

    // vector<bool> visited(n, false);  // Changed to vector<bool>
    // vector<int> component(n, -1);
    // unordered_map<int, int> componentSize;
    // int componentId = 0;

    // // DFS traversal to find connected components
    // for (int i = 0; i < n; i++) {
    //     if (!visited[i]) {
    //         componentSize[componentId] = 0;  // initializing the size of the component
    //         dfs(i, visited, adjList, componentSize, component, componentId);
    //         componentId++;
    //     }
    // }

    // // Count malware nodes in each component
    // unordered_map<int, int> malwareCount;
    // for (int node : initial) {
    //     int compId = component[node];
    //     malwareCount[compId]++;
    // }

    // // Evaluate the impact of removing malware nodes
    // int maxSaved = 0, result = -1;
    // for (int node : initial) {
    //     int compId = component[node];
        
    //     if (malwareCount[compId] == 1) {  // Can save component only if there is exactly one malware node
    //         int saved = componentSize[compId];  // The size of the component that can be saved

    //         if (saved > maxSaved || (saved == maxSaved && node < result)) {
    //             maxSaved = saved;
    //             result = node;
    //         }
    //     }
    // }

    // // If no node can save any component, return the smallest initial node
    // if (result == -1) {
    //     result = *min_element(initial.begin(), initial.end());
    // }

    // return result;
}





};
